<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>C MIMO: src/MIMO/pds_telecom.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxygen-awesome.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="newlogobg.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">C MIMO
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('pds__telecom_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">pds_telecom.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &quot;../matrix/matrix.h&quot;</code><br />
<code>#include &lt;gsl/gsl_linalg.h&gt;</code><br />
<code>#include &lt;gsl/gsl_rng.h&gt;</code><br />
<code>#include &lt;gsl/gsl_randist.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &lt;math.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;libgen.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;unistd.h&gt;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for pds_telecom.c:</div>
<div class="dyncontent">
<div class="center"><img src="pds__telecom_8c__incl.png" border="0" usemap="#asrc_2MIMO_2pds__telecom_8c" alt=""/></div>
<map name="asrc_2MIMO_2pds__telecom_8c" id="asrc_2MIMO_2pds__telecom_8c">
<area shape="rect" title=" " alt="" coords="612,5,793,32"/>
<area shape="rect" title=" " alt="" coords="5,80,72,107"/>
<area shape="rect" title=" " alt="" coords="126,155,197,181"/>
<area shape="rect" href="matrix_8h_source.html" title=" " alt="" coords="147,80,283,107"/>
<area shape="rect" title=" " alt="" coords="307,80,426,107"/>
<area shape="rect" title=" " alt="" coords="451,80,555,107"/>
<area shape="rect" title=" " alt="" coords="579,80,707,107"/>
<area shape="rect" title=" " alt="" coords="731,80,795,107"/>
<area shape="rect" title=" " alt="" coords="819,80,887,107"/>
<area shape="rect" title=" " alt="" coords="911,80,982,107"/>
<area shape="rect" title=" " alt="" coords="1007,80,1081,107"/>
<area shape="rect" title=" " alt="" coords="1105,80,1188,107"/>
<area shape="rect" title=" " alt="" coords="1212,80,1287,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6f66531e71ad9182d91d808b3982dc7a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a6f66531e71ad9182d91d808b3982dc7a">calculate_capacity</a> (double snr_dB)</td></tr>
<tr class="memdesc:a6f66531e71ad9182d91d808b3982dc7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the capacity of a communication channel.  <a href="pds__telecom_8c.html#a6f66531e71ad9182d91d808b3982dc7a">More...</a><br /></td></tr>
<tr class="separator:a6f66531e71ad9182d91d808b3982dc7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cec802e673a884207ba799d1d0a98b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a7cec802e673a884207ba799d1d0a98b7">calculate_EVM</a> (<a class="el" href="structcomplexo.html">complexo</a> **original_signal, <a class="el" href="structcomplexo.html">complexo</a> **received_signal, int Nstream, long int Nsymbol)</td></tr>
<tr class="memdesc:a7cec802e673a884207ba799d1d0a98b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Error Vector Magnitude (EVM) of a signal.  <a href="pds__telecom_8c.html#a7cec802e673a884207ba799d1d0a98b7">More...</a><br /></td></tr>
<tr class="separator:a7cec802e673a884207ba799d1d0a98b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a493369f2202b00e5400d4bcb9f8eb6d9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a493369f2202b00e5400d4bcb9f8eb6d9">calculate_SNR</a> (<a class="el" href="structcomplexo.html">complexo</a> **original_signal, <a class="el" href="structcomplexo.html">complexo</a> **received_signal, int Nstream, long int Nsymbol)</td></tr>
<tr class="memdesc:a493369f2202b00e5400d4bcb9f8eb6d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function calculates the Signal-to-Noise Ratio (SNR) of a signal.  <a href="pds__telecom_8c.html#a493369f2202b00e5400d4bcb9f8eb6d9">More...</a><br /></td></tr>
<tr class="separator:a493369f2202b00e5400d4bcb9f8eb6d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac83844d4b0d2fd01030ef22aee1f07e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#ac83844d4b0d2fd01030ef22aee1f07e9">getUserInput</a> (int *Nr, int *Nt, int *r)</td></tr>
<tr class="memdesc:ac83844d4b0d2fd01030ef22aee1f07e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get user input for the values of Nr, Nt, and r to custom mode.  <a href="pds__telecom_8c.html#ac83844d4b0d2fd01030ef22aee1f07e9">More...</a><br /></td></tr>
<tr class="separator:ac83844d4b0d2fd01030ef22aee1f07e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab15359648110ac707e2aa5658f4a4312"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#ab15359648110ac707e2aa5658f4a4312">tx_data_read</a> (FILE *fp, long int numBytes)</td></tr>
<tr class="memdesc:ab15359648110ac707e2aa5658f4a4312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads data from a file and converts it into an array of integers.  <a href="pds__telecom_8c.html#ab15359648110ac707e2aa5658f4a4312">More...</a><br /></td></tr>
<tr class="separator:ab15359648110ac707e2aa5658f4a4312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c53251390c9eb0d28ab94ed4aae790f"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a1c53251390c9eb0d28ab94ed4aae790f">tx_data_padding</a> (int *s, long int numBytes, int Npadding)</td></tr>
<tr class="memdesc:a1c53251390c9eb0d28ab94ed4aae790f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs padding of the data with zeros.  <a href="pds__telecom_8c.html#a1c53251390c9eb0d28ab94ed4aae790f">More...</a><br /></td></tr>
<tr class="separator:a1c53251390c9eb0d28ab94ed4aae790f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e9ef869be44bc1f0821428f9fd46ce6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a0e9ef869be44bc1f0821428f9fd46ce6">tx_qam_mapper</a> (int *s, long int numQAM)</td></tr>
<tr class="memdesc:a0e9ef869be44bc1f0821428f9fd46ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps binary data into a sequence of QAM symbols.  <a href="pds__telecom_8c.html#a0e9ef869be44bc1f0821428f9fd46ce6">More...</a><br /></td></tr>
<tr class="separator:a0e9ef869be44bc1f0821428f9fd46ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf975ddcdcb95ab5e2fc261a9f32dfa3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#acf975ddcdcb95ab5e2fc261a9f32dfa3">tx_layer_mapper</a> (<a class="el" href="structcomplexo.html">complexo</a> *v, int Nstream, long int Nsymbol)</td></tr>
<tr class="memdesc:acf975ddcdcb95ab5e2fc261a9f32dfa3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps data from a complex vector to a complex matrix.  <a href="pds__telecom_8c.html#acf975ddcdcb95ab5e2fc261a9f32dfa3">More...</a><br /></td></tr>
<tr class="separator:acf975ddcdcb95ab5e2fc261a9f32dfa3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af34debfab01a53ac162063f8df9286d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#af34debfab01a53ac162063f8df9286d2">rx_layer_demapper</a> (<a class="el" href="structcomplexo.html">complexo</a> **mtx_stream, int Nstream, long int numBytes)</td></tr>
<tr class="memdesc:af34debfab01a53ac162063f8df9286d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maps data from a complex matrix to a complex vector.  <a href="pds__telecom_8c.html#af34debfab01a53ac162063f8df9286d2">More...</a><br /></td></tr>
<tr class="separator:af34debfab01a53ac162063f8df9286d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4c4ca22fa77b6407d3e8d91118ee0a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a6f4c4ca22fa77b6407d3e8d91118ee0a">rx_qam_demapper</a> (<a class="el" href="structcomplexo.html">complexo</a> *vmap, long int numQAM)</td></tr>
<tr class="memdesc:a6f4c4ca22fa77b6407d3e8d91118ee0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Demaps QAM symbols to binary data.  <a href="pds__telecom_8c.html#a6f4c4ca22fa77b6407d3e8d91118ee0a">More...</a><br /></td></tr>
<tr class="separator:a6f4c4ca22fa77b6407d3e8d91118ee0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93398a6e73daf2dd1866ab475486468c"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a93398a6e73daf2dd1866ab475486468c">rx_data_depadding</a> (int *s, long int numBytes, int Nstream)</td></tr>
<tr class="memdesc:a93398a6e73daf2dd1866ab475486468c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the "null" symbols that were filled (padding).  <a href="pds__telecom_8c.html#a93398a6e73daf2dd1866ab475486468c">More...</a><br /></td></tr>
<tr class="separator:a93398a6e73daf2dd1866ab475486468c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a0b1e728db06c6e0e3eb03eeae5bc9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#ac1a0b1e728db06c6e0e3eb03eeae5bc9">rx_data_write</a> (int *s, long int numBytes, char *fileName)</td></tr>
<tr class="memdesc:ac1a0b1e728db06c6e0e3eb03eeae5bc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recovers the original bytes.  <a href="pds__telecom_8c.html#ac1a0b1e728db06c6e0e3eb03eeae5bc9">More...</a><br /></td></tr>
<tr class="separator:ac1a0b1e728db06c6e0e3eb03eeae5bc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a298d2f00fa7ec79d743a4d672c769ab2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a298d2f00fa7ec79d743a4d672c769ab2">general_matrix_product</a> (<a class="el" href="structcomplexo.html">complexo</a> **mtx_a, <a class="el" href="structcomplexo.html">complexo</a> **mtx_b, int linhas_a, int colunas_a, int linhas_b, int colunas_b)</td></tr>
<tr class="memdesc:a298d2f00fa7ec79d743a4d672c769ab2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the multiplication of two complex matrices.  <a href="pds__telecom_8c.html#a298d2f00fa7ec79d743a4d672c769ab2">More...</a><br /></td></tr>
<tr class="separator:a298d2f00fa7ec79d743a4d672c769ab2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb4d08c007fd5c91867f7bf5452aad48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#adb4d08c007fd5c91867f7bf5452aad48">channel_gen</a> (int Nr, int Nt, double sigma)</td></tr>
<tr class="memdesc:adb4d08c007fd5c91867f7bf5452aad48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a complex matrix representing a transfer channel.  <a href="pds__telecom_8c.html#adb4d08c007fd5c91867f7bf5452aad48">More...</a><br /></td></tr>
<tr class="separator:adb4d08c007fd5c91867f7bf5452aad48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44aedaa1c50fcc2c6c88f232cff45e85"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a44aedaa1c50fcc2c6c88f232cff45e85">channel_rd_gen</a> (int Nr, int Nt, double sigma)</td></tr>
<tr class="memdesc:a44aedaa1c50fcc2c6c88f232cff45e85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a complex matrix representing the noise in the communication channel.  <a href="pds__telecom_8c.html#a44aedaa1c50fcc2c6c88f232cff45e85">More...</a><br /></td></tr>
<tr class="separator:a44aedaa1c50fcc2c6c88f232cff45e85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734a93faf0ec02dc693c60447ae509d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a734a93faf0ec02dc693c60447ae509d6">transposed_channel_svd</a> (<a class="el" href="structcomplexo.html">complexo</a> **H, <a class="el" href="structcomplexo.html">complexo</a> **Uh, <a class="el" href="structcomplexo.html">complexo</a> **Sh, <a class="el" href="structcomplexo.html">complexo</a> **Vh, int Tlinhas, int Tcolunas)</td></tr>
<tr class="memdesc:a734a93faf0ec02dc693c60447ae509d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Singular Value Decomposition (SVD) on a transposed matrix.  <a href="pds__telecom_8c.html#a734a93faf0ec02dc693c60447ae509d6">More...</a><br /></td></tr>
<tr class="separator:a734a93faf0ec02dc693c60447ae509d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573cdce01ea489eff0d0c6cf835f0fcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a573cdce01ea489eff0d0c6cf835f0fcb">square_channel_svd</a> (<a class="el" href="structcomplexo.html">complexo</a> **H, <a class="el" href="structcomplexo.html">complexo</a> **Uh, <a class="el" href="structcomplexo.html">complexo</a> **Sh, <a class="el" href="structcomplexo.html">complexo</a> **Vh, int linhas, int colunas)</td></tr>
<tr class="memdesc:a573cdce01ea489eff0d0c6cf835f0fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs Singular Value Decomposition (SVD) on a square matrix.  <a href="pds__telecom_8c.html#a573cdce01ea489eff0d0c6cf835f0fcb">More...</a><br /></td></tr>
<tr class="separator:a573cdce01ea489eff0d0c6cf835f0fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb2e62a8dca68179c8f01f5a3dc6eb7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a7cb2e62a8dca68179c8f01f5a3dc6eb7">tx_precoder</a> (<a class="el" href="structcomplexo.html">complexo</a> **V, <a class="el" href="structcomplexo.html">complexo</a> **x, int Vlinhas, int Vcolunas, int xlinhas, int xcolunas)</td></tr>
<tr class="memdesc:a7cb2e62a8dca68179c8f01f5a3dc6eb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the multiplication of the stream symbols by the V matrix resulting from the SVD decomposition.  <a href="pds__telecom_8c.html#a7cb2e62a8dca68179c8f01f5a3dc6eb7">More...</a><br /></td></tr>
<tr class="separator:a7cb2e62a8dca68179c8f01f5a3dc6eb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253ab9e633bedd7bedcbf54813bdbae7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a253ab9e633bedd7bedcbf54813bdbae7">channel_transmission</a> (<a class="el" href="structcomplexo.html">complexo</a> **H, <a class="el" href="structcomplexo.html">complexo</a> **xp, int Hlinhas, int Hcolunas, int xpLinhas, int xpColunas, int r)</td></tr>
<tr class="memdesc:a253ab9e633bedd7bedcbf54813bdbae7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the transmission of the signal through the communication channel.  <a href="pds__telecom_8c.html#a253ab9e633bedd7bedcbf54813bdbae7">More...</a><br /></td></tr>
<tr class="separator:a253ab9e633bedd7bedcbf54813bdbae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac74b7bdbb1d3a2c1749d2238ebdd6733"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#ac74b7bdbb1d3a2c1749d2238ebdd6733">rx_combiner</a> (<a class="el" href="structcomplexo.html">complexo</a> **U, <a class="el" href="structcomplexo.html">complexo</a> **xt, int Ulinhas, int Ucolunas, int xtLinhas, int xtColunas)</td></tr>
<tr class="memdesc:ac74b7bdbb1d3a2c1749d2238ebdd6733"><td class="mdescLeft">&#160;</td><td class="mdescRight">Performs the multiplication of signals received by Nr antennas by the U matrix.  <a href="pds__telecom_8c.html#ac74b7bdbb1d3a2c1749d2238ebdd6733">More...</a><br /></td></tr>
<tr class="separator:ac74b7bdbb1d3a2c1749d2238ebdd6733"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e8d036544b7e74e391913edf992f155"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a2e8d036544b7e74e391913edf992f155">rx_feq</a> (<a class="el" href="structcomplexo.html">complexo</a> **S, <a class="el" href="structcomplexo.html">complexo</a> **xc, int Slinhas, int Scolunas, int xcLinhas, int xcColunas)</td></tr>
<tr class="memdesc:a2e8d036544b7e74e391913edf992f155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes the interference from the H channel (S matrix from the SVD decomposition)  <a href="pds__telecom_8c.html#a2e8d036544b7e74e391913edf992f155">More...</a><br /></td></tr>
<tr class="separator:a2e8d036544b7e74e391913edf992f155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d55c8ce5c8bae89bbd6dd43a1dd7b55"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="pds__telecom_8c.html#a0d55c8ce5c8bae89bbd6dd43a1dd7b55">generate_statistics</a> (int *s, int *finals, long int numBytes, int teste, int Nr, int Nt, double r, <a class="el" href="structcomplexo.html">complexo</a> **original_signal, <a class="el" href="structcomplexo.html">complexo</a> **received_signal, int Nstream, long int Nsymbol)</td></tr>
<tr class="memdesc:a0d55c8ce5c8bae89bbd6dd43a1dd7b55"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates and outputs statistics about the transmitted and received QAM symbols.  <a href="pds__telecom_8c.html#a0d55c8ce5c8bae89bbd6dd43a1dd7b55">More...</a><br /></td></tr>
<tr class="separator:a0d55c8ce5c8bae89bbd6dd43a1dd7b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b6aefb69421016701b4bf643a6fe61e"><td class="memItemLeft" align="right" valign="top"><a id="a7b6aefb69421016701b4bf643a6fe61e"></a>
<a class="el" href="structcomplexo.html">complexo</a> **&#160;</td><td class="memItemRight" valign="bottom"><b>expandMatrix</b> (<a class="el" href="structcomplexo.html">complexo</a> **matriz, int linhas, int colunas, int linhasExtras, int padding)</td></tr>
<tr class="separator:a7b6aefb69421016701b4bf643a6fe61e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fc483247769776ab74af61caf8b616f"><td class="memItemLeft" align="right" valign="top"><a id="a6fc483247769776ab74af61caf8b616f"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_running_in_wsl</b> ()</td></tr>
<tr class="separator:a6fc483247769776ab74af61caf8b616f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75acb5f2a6b6c148958a55c275cbdb11"><td class="memItemLeft" align="right" valign="top"><a id="a75acb5f2a6b6c148958a55c275cbdb11"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><b>is_wsl_there</b> ()</td></tr>
<tr class="separator:a75acb5f2a6b6c148958a55c275cbdb11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memItemLeft" align="right" valign="top"><a id="ae66f6b31b5ad750f1fe042a706a4e3d4"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>main</b> ()</td></tr>
<tr class="separator:ae66f6b31b5ad750f1fe042a706a4e3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6f66531e71ad9182d91d808b3982dc7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f66531e71ad9182d91d808b3982dc7a">&#9670;&nbsp;</a></span>calculate_capacity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_capacity </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>snr_dB</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the capacity of a communication channel. </p>
<p>The capacity is calculated using the Shannon Capacity formula, which is based on the signal-to-noise ratio (SNR). The SNR is provided in decibels (dB) and is converted to linear scale inside the function. The capacity is returned in bits per symbol.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">snr_dB</td><td>The signal-to-noise ratio (SNR) in decibels (dB). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The capacity of the channel in bits per symbol. </dd></dl>

</div>
</div>
<a id="a7cec802e673a884207ba799d1d0a98b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cec802e673a884207ba799d1d0a98b7">&#9670;&nbsp;</a></span>calculate_EVM()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_EVM </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>original_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>received_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>Nsymbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the Error Vector Magnitude (EVM) of a signal. </p>
<p>EVM is a measure of the performance of a digital radio transmitter or receiver. A lower EVM means a better performance. In this function, the EVM is calculated by comparing the original transmitted signal with the received signal.</p>
<p>The function first calculates the power of the error signal and the power of the received signal. Then, it calculates the EVM as the square root of the ratio of the error power to the signal power. If the signal power is zero, the function returns infinity. Finally, the EVM is converted to decibels (dB) before being returned.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original_signal</td><td>A 2D array of complex numbers representing the original transmitted signal. </td></tr>
    <tr><td class="paramname">received_signal</td><td>A 2D array of complex numbers representing the signal received after transmission. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of streams in the signal. </td></tr>
    <tr><td class="paramname">Nsymbol</td><td>The total number of symbols in the signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated EVM of the signal in dB. If the signal power is zero, returns infinity. </dd></dl>

</div>
</div>
<a id="a493369f2202b00e5400d4bcb9f8eb6d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a493369f2202b00e5400d4bcb9f8eb6d9">&#9670;&nbsp;</a></span>calculate_SNR()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double calculate_SNR </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>original_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>received_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>Nsymbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function calculates the Signal-to-Noise Ratio (SNR) of a signal. </p>
<p>SNR is a measure that compares the level of a desired signal to the level of background noise. It is defined as the ratio of signal power to the noise power. A higher SNR indicates a signal less affected by noise. In this function, the SNR is calculated by comparing the original transmitted signal with the received signal.</p>
<p>The function takes as input two 2D arrays of complex numbers representing the original and received signals, the number of streams in the signal, and the total number of symbols in the signal.</p>
<p>The calculated SNR is returned in decibels (dB).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">original_signal</td><td>A 2D array of complex numbers representing the original transmitted signal. </td></tr>
    <tr><td class="paramname">received_signal</td><td>A 2D array of complex numbers representing the signal received after transmission. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of streams in the signal. </td></tr>
    <tr><td class="paramname">Nsymbol</td><td>The total number of symbols in the signal. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The calculated SNR of the signal in dB. </dd></dl>

</div>
</div>
<a id="adb4d08c007fd5c91867f7bf5452aad48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb4d08c007fd5c91867f7bf5452aad48">&#9670;&nbsp;</a></span>channel_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** channel_gen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a complex matrix representing a transfer channel. </p>
<p>This function generates a complex matrix that represents a transfer channel between transmitting antennas and receiving antennas. The elements of the matrix are random complex numbers with the imaginary part set to zero.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nr</td><td>The number of receiving antennas. </td></tr>
    <tr><td class="paramname">Nt</td><td>The number of transmitting antennas. </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation value for the channel creation.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A complex matrix representing the generated transfer channel. The caller is responsible for freeing the allocated memory using the free() function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the GSL library is correctly installed and linked to the project. </dd></dl>

</div>
</div>
<a id="a44aedaa1c50fcc2c6c88f232cff45e85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44aedaa1c50fcc2c6c88f232cff45e85">&#9670;&nbsp;</a></span>channel_rd_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** channel_rd_gen </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates a complex matrix representing the noise in the communication channel. </p>
<p>This function generates a complex matrix representing the noise in the communication channel. The resulting matrix has dimensions Nr x Nt, where Nr is the number of receiving antennas and Nt is the number of transmitting antennas. The values of the matrix elements are generated randomly with a Gaussian distribution with mean 0 and standard deviation sigma.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nr</td><td>The number of receiving antennas. </td></tr>
    <tr><td class="paramname">Nt</td><td>The number of transmitting antennas. </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation of the noise.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A complex matrix representing the noise in the communication channel. The caller is responsible for freeing the allocated memory using the free() function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the GSL library is correctly installed and linked to the project. </dd></dl>

</div>
</div>
<a id="a253ab9e633bedd7bedcbf54813bdbae7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253ab9e633bedd7bedcbf54813bdbae7">&#9670;&nbsp;</a></span>channel_transmission()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** channel_transmission </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>xp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Hlinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Hcolunas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xpLinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xpColunas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the transmission of the signal through the communication channel. </p>
<p>This function performs the transmission of the input signal xp through the communication channel represented by the H matrix. The result of the transmission is calculated by multiplying the H matrix by the xp vector. In addition, a Rd noise is added to the transmitted signal to simulate the characteristics of the communication channel.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>Matrix representing the communication channel. </td></tr>
    <tr><td class="paramname">xp</td><td>Input vector to be transmitted through the channel. </td></tr>
    <tr><td class="paramname">Hlinhas</td><td>The number of rows in the H matrix. </td></tr>
    <tr><td class="paramname">Hcolunas</td><td>The number of columns in the H matrix. </td></tr>
    <tr><td class="paramname">xpLinhas</td><td>The number of rows in the xp vector. </td></tr>
    <tr><td class="paramname">xpColunas</td><td>The number of columns in the xp vector. </td></tr>
    <tr><td class="paramname">r</td><td>The value that defines the range of the noise to be added: 0 for [-0.001, 0.001], 1 for [-0.01, 0.01], 2 for [-0.5, 0.5], 3 for [-1, 1].</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The resulting matrix of the signal transmission through the channel, plus the noise. </dd></dl>

</div>
</div>
<a id="a298d2f00fa7ec79d743a4d672c769ab2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a298d2f00fa7ec79d743a4d672c769ab2">&#9670;&nbsp;</a></span>general_matrix_product()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** general_matrix_product </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>mtx_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>mtx_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linhas_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colunas_a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linhas_b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colunas_b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the multiplication of two complex matrices. </p>
<p>This function performs the multiplication of two complex matrices <code>mtx_a</code> and <code>mtx_b</code>, resulting in a new matrix <code>matriz</code>. The validation of the multiplication operation is done by checking if the number of columns of the matrix <code>mtx_a</code> is equal to the number of rows of the matrix <code>mtx_b</code>. If they are not compatible, the function displays an error message and terminates the program.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx_a</td><td>The first complex matrix to be multiplied. </td></tr>
    <tr><td class="paramname">mtx_b</td><td>The second complex matrix to be multiplied. </td></tr>
    <tr><td class="paramname">linhas_a</td><td>The number of rows of the matrix <code>mtx_a</code>. </td></tr>
    <tr><td class="paramname">colunas_a</td><td>The number of columns of the matrix <code>mtx_a</code>. </td></tr>
    <tr><td class="paramname">linhas_b</td><td>The number of rows of the matrix <code>mtx_b</code>. </td></tr>
    <tr><td class="paramname">colunas_b</td><td>The number of columns of the matrix <code>mtx_b</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new complex matrix resulting from the multiplication of <code>mtx_a</code> and <code>mtx_b</code>. The caller is responsible for freeing the allocated memory using the free() function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>This function assumes that the matrices <code>mtx_a</code> and <code>mtx_b</code> have been correctly allocated and have compatible dimensions for multiplication. </dd></dl>

</div>
</div>
<a id="a0d55c8ce5c8bae89bbd6dd43a1dd7b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d55c8ce5c8bae89bbd6dd43a1dd7b55">&#9670;&nbsp;</a></span>generate_statistics()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void generate_statistics </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>finals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>teste</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>r</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>original_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>received_signal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>Nsymbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generates and outputs statistics about the transmitted and received QAM symbols. </p>
<p>This function calculates and outputs statistics about the transmitted and received QAM symbols, comparing the transmitted symbols vector <code>s</code> with the received symbols vector <code>finals</code>. It counts the number of correct and incorrect transmissions and calculates the percentage of symbols received with errors in relation to the total symbols. It also calculates the Bit Error Rate (BER), Signal-to-Noise Ratio (SNR), Error Vector Magnitude (EVM), and the capacity of the communication channel. The results are displayed on the standard output and also saved to a CSV file named "output.csv".</p>
<p>The CSV file contains the following columns:</p><ol type="1">
<li><code>test</code>: An integer parameter used for testing.</li>
<li><code>Nr</code>: The number of receive antennas.</li>
<li><code>Nt</code>: The number of transmit antennas.</li>
<li><code>r</code>: Noise interval.</li>
<li><code>error_percentage</code>: The percentage of symbols received with errors in relation to the total symbols.</li>
<li><code>ber</code>: The Bit Error Rate (BER).</li>
<li><code>snr_dB</code>: The Signal-to-Noise Ratio (SNR) in decibels.</li>
<li><code>evm_dB</code>: The Error Vector Magnitude (EVM) in decibels.</li>
<li><code>cap</code>: The capacity of the communication channel in bits per symbol.</li>
</ol>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>The vector of transmitted QAM symbols. </td></tr>
    <tr><td class="paramname">finals</td><td>The vector of received QAM symbols. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of transmitted bytes (considering 4 QAM symbols per byte). </td></tr>
    <tr><td class="paramname">teste</td><td>An integer parameter used for testing. </td></tr>
    <tr><td class="paramname">Nr</td><td>The number of receive antennas. </td></tr>
    <tr><td class="paramname">Nt</td><td>The number of transmit antennas. </td></tr>
    <tr><td class="paramname">r</td><td>The radius of the QAM constellation. </td></tr>
    <tr><td class="paramname">original_signal</td><td>A 2D array of complex numbers representing the original transmitted signal. </td></tr>
    <tr><td class="paramname">received_signal</td><td>A 2D array of complex numbers representing the signal received after transmission. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of streams in the signal. </td></tr>
    <tr><td class="paramname">Nsymbol</td><td>The total number of symbols in the signal.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function displays the statistics on the standard output and also writes them to a CSV file. Visualizations of these statistics can be viewed in the following Jupyter notebook: <a href="https://colab.research.google.com/github/lasseufpa/C_MIMO/blob/1-implement-command-line-parsing-for-antenna-or-similar-configuration-in-mimo-system-simulation/analyzer.ipynb">https://colab.research.google.com/github/lasseufpa/C_MIMO/blob/1-implement-command-line-parsing-for-antenna-or-similar-configuration-in-mimo-system-simulation/analyzer.ipynb</a> </dd></dl>

</div>
</div>
<a id="ac83844d4b0d2fd01030ef22aee1f07e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac83844d4b0d2fd01030ef22aee1f07e9">&#9670;&nbsp;</a></span>getUserInput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void getUserInput </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>Nt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get user input for the values of Nr, Nt, and r to custom mode. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">Nr</td><td>Pointer to an integer where the value for Nr will be stored. </td></tr>
    <tr><td class="paramname">Nt</td><td>Pointer to an integer where the value for Nt will be stored. </td></tr>
    <tr><td class="paramname">r</td><td>Pointer to an integer where the value for r will be stored. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac74b7bdbb1d3a2c1749d2238ebdd6733"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac74b7bdbb1d3a2c1749d2238ebdd6733">&#9670;&nbsp;</a></span>rx_combiner()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** rx_combiner </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>U</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>xt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ulinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Ucolunas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xtLinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xtColunas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the multiplication of signals received by Nr antennas by the U matrix. </p>
<p>This function uses the transposed U matrix and multiplies it by the xt vector that we are transmitting, generating the combined vector xc.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">U</td><td>Allocated U matrix. </td></tr>
    <tr><td class="paramname">xt</td><td>Transmitted xt vector. </td></tr>
    <tr><td class="paramname">Ulinhas</td><td>The number of rows in the U matrix. </td></tr>
    <tr><td class="paramname">Ucolunas</td><td>The number of columns in the U matrix. </td></tr>
    <tr><td class="paramname">xtlinhas</td><td>The number of rows in the xt vector. </td></tr>
    <tr><td class="paramname">xtcolunas</td><td>The number of columns in the xt vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the xc vector. </dd></dl>

</div>
</div>
<a id="a93398a6e73daf2dd1866ab475486468c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93398a6e73daf2dd1866ab475486468c">&#9670;&nbsp;</a></span>rx_data_depadding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* rx_data_depadding </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nstream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the "null" symbols that were filled (padding). </p>
<p>This function undoes the processing done by the data_padding function, returning our vector to its original size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the integer array containing the data. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The original number of bytes before padding. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of streams for which the array size should be a multiple. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the integer array with the original values.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function returns a new array if the original number of bytes is not a multiple of the number of streams. The caller is responsible for freeing the allocated memory using the free() function. </dd></dl>

</div>
</div>
<a id="ac1a0b1e728db06c6e0e3eb03eeae5bc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1a0b1e728db06c6e0e3eb03eeae5bc9">&#9670;&nbsp;</a></span>rx_data_write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rx_data_write </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>fileName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recovers the original bytes. </p>
<p>This function recovers the original bytes every 4 digits by performing the inverse process of the data_read function. It takes the integer array 's' and decodes it into character bytes to generate the file named 'fileName'.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the integer array containing the data. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The original number of bytes before padding. </td></tr>
    <tr><td class="paramname">fileName</td><td>The name of the file to be written.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>The function does not return a value. It writes the decoded bytes directly to the file named 'fileName'. If the file cannot be opened for writing, an error message is printed to the console. </dd></dl>

</div>
</div>
<a id="a2e8d036544b7e74e391913edf992f155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e8d036544b7e74e391913edf992f155">&#9670;&nbsp;</a></span>rx_feq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** rx_feq </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>xc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Slinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Scolunas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xcLinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xcColunas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes the interference from the H channel (S matrix from the SVD decomposition) </p>
<p>This function uses each non-zero element of the S matrix and divides it by each element of the xc vector in the same row.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>Allocated S matrix. </td></tr>
    <tr><td class="paramname">xc</td><td>Transmitted xc vector. </td></tr>
    <tr><td class="paramname">Slinhas</td><td>The number of rows in the S matrix. </td></tr>
    <tr><td class="paramname">Scolunas</td><td>The number of columns in the S matrix. </td></tr>
    <tr><td class="paramname">xcLinhas</td><td>The number of rows in the xc vector. </td></tr>
    <tr><td class="paramname">xcColunas</td><td>The number of columns in the xc vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the xf vector. </dd></dl>

</div>
</div>
<a id="af34debfab01a53ac162063f8df9286d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af34debfab01a53ac162063f8df9286d2">&#9670;&nbsp;</a></span>rx_layer_demapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>* rx_layer_demapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>mtx_stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps data from a complex matrix to a complex vector. </p>
<p>This function maps data from a complex matrix to a complex vector, where each position in the matrix represents a transmission stream. The function dynamically allocates memory for the complex vector and returns a pointer to the vector.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mtx_stream</td><td>Pointer to the complex matrix containing the data to be mapped. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of transmission streams. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes contained in the complex matrix. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the complex vector that contains the mapped data, or NULL in case of memory allocation error.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for freeing the memory allocated for the complex vector when it is no longer needed, using the free() function. </dd></dl>

</div>
</div>
<a id="a6f4c4ca22fa77b6407d3e8d91118ee0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4c4ca22fa77b6407d3e8d91118ee0a">&#9670;&nbsp;</a></span>rx_qam_demapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* rx_qam_demapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> *&#160;</td>
          <td class="paramname"><em>vmap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numQAM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Demaps QAM symbols to binary data. </p>
<p>This function takes a vector of complex numbers representing QAM symbols and performs the demapping of these symbols to binary data. Each QAM symbol is associated with a binary value, according to the following table:</p><ul>
<li>(-1, 1) -&gt; 0</li>
<li>(-1, -1) -&gt; 1</li>
<li>(1, 1) -&gt; 2</li>
<li>(1, -1) -&gt; 3</li>
<li>Others -&gt; 4</li>
</ul>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">vmap</td><td>Vector of complex numbers representing the QAM symbols. </td></tr>
    <tr><td class="paramname">numQAM</td><td>The number of QAM symbols in the vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A vector of integers containing the binary data demapped from the QAM symbols. The caller is responsible for freeing the allocated memory using the free() function.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The function returns a pointer to integer 1 if memory allocation fails. This is a non-standard practice and it's recommended to return NULL in such cases. The caller should check for NULL to ensure that memory allocation was successful. </dd></dl>

</div>
</div>
<a id="a573cdce01ea489eff0d0c6cf835f0fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573cdce01ea489eff0d0c6cf835f0fcb">&#9670;&nbsp;</a></span>square_channel_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void square_channel_svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>Uh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>Sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>Vh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>linhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colunas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs Singular Value Decomposition (SVD) on a square matrix. </p>
<p>This function performs SVD on a square matrix, represented by a matrix of complex numbers. The function only uses the real part of the matrix elements for the SVD calculation. It dynamically allocates memory for the U, V matrices and the S vector, and stores the decomposition results in the Uh, Sh, and Vh matrices.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>The square complex matrix to be decomposed. </td></tr>
    <tr><td class="paramname">Uh</td><td>The resulting U matrix from the decomposition, containing the left eigenvectors. </td></tr>
    <tr><td class="paramname">Sh</td><td>The resulting S matrix from the decomposition, containing the singular values on the diagonal. </td></tr>
    <tr><td class="paramname">Vh</td><td>The resulting V matrix from the decomposition, containing the right eigenvectors. </td></tr>
    <tr><td class="paramname">linhas</td><td>The number of rows in the H matrix. </td></tr>
    <tr><td class="paramname">colunas</td><td>The number of columns in the H matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only considers the real part of the H matrix elements for the SVD calculation. The function returns immediately if complex elements are detected in the H matrix. </dd></dl>

</div>
</div>
<a id="a734a93faf0ec02dc693c60447ae509d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734a93faf0ec02dc693c60447ae509d6">&#9670;&nbsp;</a></span>transposed_channel_svd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void transposed_channel_svd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>H</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>Uh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>Sh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>Vh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Tlinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Tcolunas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs Singular Value Decomposition (SVD) on a transposed matrix. </p>
<p>This function performs SVD on a transposed matrix, represented by a matrix of complex numbers. The function only uses the real part of the matrix elements for the SVD calculation. It dynamically allocates memory for the matrices U, V, and the vector S, and stores the decomposition results in the matrices Uh, Sh, and Vh.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">H</td><td>Transposed complex matrix to be decomposed. </td></tr>
    <tr><td class="paramname">Uh</td><td>Resulting U matrix from the decomposition, containing the left eigenvectors. </td></tr>
    <tr><td class="paramname">Sh</td><td>Resulting S matrix from the decomposition, containing the singular values on the diagonal. </td></tr>
    <tr><td class="paramname">Vh</td><td>Resulting V matrix from the decomposition, containing the right eigenvectors. </td></tr>
    <tr><td class="paramname">Tlinhas</td><td>The number of rows of the transposed matrix H. </td></tr>
    <tr><td class="paramname">Tcolunas</td><td>The number of columns of the transposed matrix H.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>This function only considers the real part of the matrix H elements for the SVD calculation. The function prints a warning if complex elements are detected in the matrix H, but ignores the imaginary part for the calculation.</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The <code>transposed_channel_svd</code> function is similar to the <code>square_channel_svd</code> function, but there's a crucial difference between them. The <code>square_channel_svd</code> function takes a square matrix as a parameter, while the <code>transposed_channel_svd</code> function takes the transposed matrix as a parameter. The transposed matrix is obtained by swapping the rows and columns of the original matrix. Therefore, while the <code>square_channel_svd</code> function performs the SVD of a square matrix, the <code>transposed_channel_svd</code> function performs the SVD of the transposed matrix. </dd></dl>

</div>
</div>
<a id="a1c53251390c9eb0d28ab94ed4aae790f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c53251390c9eb0d28ab94ed4aae790f">&#9670;&nbsp;</a></span>tx_data_padding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* tx_data_padding </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numBytes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Npadding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs padding of the data with zeros. </p>
<p>This function performs padding of the data with zeros to ensure that the size of the integer array is an integer multiple of the number of streams (Nstream). Padding is necessary when the number of bytes in the data is not a multiple of the number of streams. In such cases, padding with zeros ensures that the data can be evenly divided among the streams.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the integer array containing the data. This array should contain the binary representation of the data to be transmitted. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The original number of bytes in the data before padding. This is the size of the array pointed to by <code>s</code>. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of streams for which the array size should be a multiple. This represents the number of separate data streams that the data will be divided among. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the integer array with the padding performed, or NULL in case of memory allocation error. The caller is responsible for freeing this memory when it is no longer needed. </dd></dl>

</div>
</div>
<a id="ab15359648110ac707e2aa5658f4a4312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab15359648110ac707e2aa5658f4a4312">&#9670;&nbsp;</a></span>tx_data_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int* tx_data_read </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reads data from a file and converts it into an array of integers. </p>
<p>This function reads binary data from a file and converts it into an array of integers. Each integer in the array represents 2 bits of the original data. The conversion is done by reading two bits at a time from the binary data and storing their combined value as an integer in the array.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">fp</td><td>Pointer to the file to be read. The file should be opened in binary read mode before calling this function. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes to be read from the file. This should be the size of the data that you want to convert. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the integer array that contains the converted data, or NULL in case of memory allocation error or if the file cannot be read.</dd></dl>
<dl class="section note"><dt>Note</dt><dd>The caller is responsible for freeing the memory allocated for the integer array when it is no longer needed, using the free() function. The caller is also responsible for closing the file when it's no longer needed. </dd></dl>

</div>
</div>
<a id="acf975ddcdcb95ab5e2fc261a9f32dfa3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf975ddcdcb95ab5e2fc261a9f32dfa3">&#9670;&nbsp;</a></span>tx_layer_mapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** tx_layer_mapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> *&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Nstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>Nsymbol</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps data from a complex vector to a complex matrix. </p>
<p>This function maps data from a complex vector to a complex matrix, where each position in the matrix represents a transmission stream. The function dynamically allocates memory for the complex matrix and returns a pointer to the matrix.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td>Pointer to the complex vector containing the data to be mapped. </td></tr>
    <tr><td class="paramname">Nstream</td><td>The number of transmission streams. </td></tr>
    <tr><td class="paramname">Nsymbol</td><td>The number of symbols contained in the complex vector. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the complex matrix that contains the mapped data, or NULL in case of memory allocation error. </dd></dl>

</div>
</div>
<a id="a7cb2e62a8dca68179c8f01f5a3dc6eb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb2e62a8dca68179c8f01f5a3dc6eb7">&#9670;&nbsp;</a></span>tx_precoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>** tx_precoder </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>V</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structcomplexo.html">complexo</a> **&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Vlinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>Vcolunas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xlinhas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xcolunas</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Performs the multiplication of the stream symbols by the V matrix resulting from the SVD decomposition. </p>
<p>This function uses the V matrix and multiplies it by the x vector we are transmitting, generating the precoded vector xp.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">V</td><td>The V matrix that was allocated in main. </td></tr>
    <tr><td class="paramname">x</td><td>The x vector that is being transmitted </td></tr>
    <tr><td class="paramname">Vlinhas</td><td>The number of rows in the V matrix. </td></tr>
    <tr><td class="paramname">Vcolunas</td><td>The number of columns in the V matrix. </td></tr>
    <tr><td class="paramname">xlinhas</td><td>The number of rows in the x vector. </td></tr>
    <tr><td class="paramname">xcolunas</td><td>The number of columns in the x vector.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the xp vector </dd></dl>

</div>
</div>
<a id="a0e9ef869be44bc1f0821428f9fd46ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e9ef869be44bc1f0821428f9fd46ce6">&#9670;&nbsp;</a></span>tx_qam_mapper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structcomplexo.html">complexo</a>* tx_qam_mapper </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long int&#160;</td>
          <td class="paramname"><em>numQAM</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maps binary data into a sequence of QAM symbols. </p>
<p>This function maps binary data into a sequence of QAM (Quadrature Amplitude Modulation) symbols represented by complex numbers. The function dynamically allocates memory for the complex vector and returns a pointer to this vector.</p>
<p>The mapping is as follows: 0 -&gt; (-1, 1) 1 -&gt; (-1, -1) 2 -&gt; (1, 1) 3 -&gt; (1, -1) Any other value -&gt; (0, 0)</p>
<p>The <code>complexo</code> type is a struct with two members: <code>real</code> and <code>img</code>, representing the real and imaginary parts of a complex number.</p>
<p>If memory allocation fails, the function returns NULL and prints an error message to stdout. It's the caller's responsibility to check the return value and handle the error appropriately.</p>
<p>The caller is also responsible for freeing the memory allocated by this function when it's no longer needed.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">s</td><td>Pointer to the integer array containing the binary data. </td></tr>
    <tr><td class="paramname">numBytes</td><td>The number of bytes contained in the integer array. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the complex vector that contains the mapped QAM symbols, or NULL in case of memory allocation error. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_10885a9296a0c4572008c172e9c86d2e.html">MIMO</a></li><li class="navelem"><a class="el" href="pds__telecom_8c.html">pds_telecom.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
